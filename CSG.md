# [单选题]

## 一. 计算机组成原理

1. 机器字长是指()。

A.
存储器单元和寄存器的位数

B.
CPU控制总线根数

C.
CPU地址总线位数

D.
CPU一次能处理的数据位数

正确答案：
D

2. 下列关于中断或异常情况的叙述中，错误的是()。

A.
“访存时缺页”属于中断 `当一个程序尝试访问其虚拟内存空间中的某个部分，而这部分内存当前没有被加载到物理内存（RAM）中时，就会发生缺页异常。`

B.
“整数除以0”属于异常

C.
“DMA传送结束”属于中断 `直接存储访问（Direct Memory Access, DMA）技术，这是一种允许硬件子系统（如磁盘驱动器、声卡等）直接向主内存读写数据而无需CPU介入的技术。当一个DMA传输操作完成时，DMA控制器会向CPU发出一个中断信号，通知CPU数据已成功传输完毕。`

D.
“算术操作数溢出”属于异常

正确答案：
A

`异常也称内中断，是指在处理器和内存内部发生的中断，如缺页中断、算数操作溢出、非法指令、除数为零、地址非法等。中断也称外中断，是指来自处理器和内存以外的部件引起的中断，如I/O中断、外部信号中断等。`



3. 数据的高位保存在存储器的低地址中，而数据的低位保存在存储器的高地址中，这种模式称为()。

A.
小端模式

B.
大端模式

C.
低端模式

D.
高端模式

正确答案：
B

4. 针对8位二进制数，下列说法正确的是()。

A.
-127的补码为10000000 `Two's Complement（补码）1000 0001`

B.
-127的反码等于0的移码 `原码1111 1111，反码1000 0000。移码加上偏移量128，即0+128，也就是1000 0000`

C.
+1的移码等于-127的反码 `One's Complement（反码）` `移码1000 0001`

D.
O的补码等于-1的反码 `原码1000 0001 反码1111 1110`

正确答案：
B

`0和正数反码/补码都是自身，负数补码是反码加1`

5. 若某数x的真值为-0.1010，在计算机中该数表示为1.0110，则该数所用的表示方法是()。

A.
原码 `1.1010`

B.
补码 `1.0110`

C.
反码 `1.0101`

D.
移码

正确答案：
B

6. 已知字符“0”的7位ASCII码是30H，假设在7位ASCII的最高位前面添加一位偶校验位，则字符“1”的偶校验ASCII码是()

A.
B0H `尾数带H，表示是十六进制，Hexadecimal。0011 0001 == 31H，1011 0001 == B1H`

B.
30H

C.
B1H

D.
31H

正确答案：
C

`当我们在这个7位ASCII码的最高位前添加一个偶校验位时，目的是确保整个字节（8位）中“1”的数量是偶数。这样做是为了检测和纠正错误。`

7. 下列说法正确的是()

A.
采用变形补码进行加减运算可以避免溢出 `变形补码可以判断溢出，但是不能避免溢出。浮点数阶码超过上限也会溢出，同号数相加或异号数相减都会产生溢出。`

B.
只有定点数运算才有可能溢出，浮点数运算不会产生溢出

C.
只有带符号数的运算才有可能产生溢出

D.
将两个正数相加有可能产生溢出

正确答案：
D

8. 某DRAM芯片，其存储容量为512Kx8位，该芯片的地址线和数据线数目分别为()。

A.
8，512

B.
512，8

C.
18，8

D.
19，8 `512k == 512 * 1024 == 2^9 + 2^10 == 2^19`

正确答案：
D

`512Kx8表示可以存储512K个8位数据`

```c
存储方式

    SRAM{静态随机存取存储器Static random-access memory}利用双稳态的触发器来存储每一位数据，这意味着它可以在不刷新的情况下保持数据，只要电源保持开启。
    DRAM{动态随机访问存储器Dynamic random-access memory}通过电荷来存储数据，每个数据位被存储在一个微小的电容器中。由于电荷会逐渐泄漏，DRAM需要定期刷新（几毫秒一次）来保持数据。

速度

    SRAM比DRAM快，因为它不需要定期刷新电荷。这使得SRAM更适合作为缓存(Cache, 通常位于CPU内部)使用，在处理器附近提供快速的数据访问。
    DRAM由于其结构原因，访问速度较慢，但是它通常用于作为系统的主内存(内存条)，因为它可以提供更大的存储容量。

成本和容量

    SRAM的成本较高，因为它使用的是比DRAM复杂得多的电路。因此，同等存储容量下，SRAM比DRAM更昂贵，也是为什么SRAM主要用作缓存的原因。
    DRAM成本较低，能够提供更大的存储容量，适合用作系统的主内存。

功耗

    SRAM由于不需要定期刷新，其功耗相对较低（特别是在待机状态下）。
    DRAM需要定期刷新来保持数据，这会导致其在功耗上相对较高。

简而言之，SRAM主要用作高速缓存，因为它速度快、功耗低，但成本高、容量低。DRAM由于其较低的成本和较高的存储密度，通常用作计算机的主内存，尽管它在速度和功耗方面表现不如SRAM。

```

10. 扩展操作码是()。

A.
操作码字段外辅助操作字段的代码

B.
操作码字段中用来进行指令分类的代码

C.
指令格式中的操作码

D.
一种指令优化技术，不同地址数指令可以具有不同的操作码长度

正确答案：
D

`所谓扩展操作码，是指让操作数地址多的指令的操作码字段短一些，操作数地址个数少的指令的操作码字段长一些，这样既能充分地利用指令的各个字段，又能在不增加指令长度的情况下扩展操作码的位数，使它能表示更多的指令。`


11. 对某个寄存器中操作数的寻址方式称为()寻址。

A.
直接

B.
间接

C.
寄存器

D.
寄存器间接 `存的数值的地址`

正确答案：
C


## 二、数据结构与算法

1. 采用顺序查找法查找长度为n的顺序表时，查找成功的平均查找长度为

A.
(n-1)/2

B.
(n+1)/2

C.
n

D.
n/2

正确答案：
B

`    在最好的情况下，查找的长度是1（第一个元素就是要查找的元素）。    在最坏的情况下，查找的长度是n（最后一个元素是要查找的元素）。    因此，查找成功的平均查找长度就是从第一个元素到最后一个元素的平均位置，即(1+n)/2`

6. 设线性表的长度为15，采用冒泡排序，在最坏的情况下需要比较的次数为()。

A.
66

B.
78

C.
105

D.
112

正确答案：
C `最坏的情况下需要比较n(n-1)/2次`

```c
对于[8, 5, 4, 3, 2]的冒泡排序次数为4+3+2+1 = 10

抽象来说就是(n−1)+(n−2)+⋯+2+1 = n(n−1)​/2
```


2. 在循环队列中用数组A［0, m-1］存放队列元素, 其队头指针和队尾指针分别为front和rear, 则当前队列中的元素个数是()

A.
(front-rear+1)%m

B.
(rear-front+1)%m

C.
(front-rear+m)%m

D.
(rear-front+m)%m

正确答案：
D

```c
    队尾指针在队头指针之后：这是最直接的情况，元素个数直接是rear - front。但是在循环队列中，当队尾绕过数组末尾再从头开始时，这个直接计算就不再适用。

    队尾指针“绕回”到队头指针之前：当队尾指针绕过数组末尾再从头开始，就好像它在队头指针的前面。这时，你需要加上数组的长度m来“补偿”绕回的部分，然后再计算两者的差值，即(rear - front + m)。这样做的目的是确保计算的结果始终为正。{但是此时可能大于m-1个元素了}

    取模运算：使用%m的原因是保证结果落在合理的范围内（0到m-1之间）。这也处理了队列刚好满时（元素个数等于数组长度m）的情况，确保计算结果是正确的。
```

4. 下列关于栈的叙述，正确的是()。

A.
只要确定了入栈序列，就可以确定出栈序列

B.
栈是一种操作受限的线性表，只允许在其两端进行操作 `栈：后进先出。所以为一端`

C.
采用非递归方式重写递归程序时，必须使用栈 `递归就是调用函数自身`

D.
函数调用时，可以使用栈来保存必要的信息

正确答案：
D

```java
举个简单的例子，假设有一个入栈序列1, 2, 3。这里有几种不同的出栈情况可能发生：

    如果我们在每个元素入栈后立即出栈，那么出栈序列将是3, 2, 1。
    如果我们让1和2入栈，然后出栈2，入栈3，然后依次出栈3和1，出栈序列将是2, 3, 1。
    如果我们让所有元素入栈，然后依次出栈，出栈序列将是3, 2, 1。

//普通递归版本
public class Factorial {
   public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
    // 定义一个递归方法来计算阶乘
    public static int factorial(int n) {
        // 基本情况
        if (n == 0) {
            return 1;
        }
        // 递归步骤
        else {
            return n * factorial(n - 1);
        }
    }
}

//使用栈stack版本 
import java.util.Stack;
public class FactorialWithStack {    
    public static int factorial(int n) {
        // 创建一个栈来存储中间结果
        Stack<Integer> stack = new Stack<>();        
        // 将n到1的所有数依次入栈
        while (n > 0) {
            stack.push(n);
            n--;
        }        
        // 初始化结果为1
        int result = 1;        
        // 遍历栈，依次弹出所有元素并进行乘法运算
        while (!stack.isEmpty()) {
            result *= stack.pop();
        }        
        return result;
    }
    public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
}

//不使用递归不使用栈版本
public class FactorialNonRecursive {
    // 定义一个非递归方法来计算阶乘
    public static int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
    public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
}

栈（Stack）

    管理方式：栈是自动管理的数据结构，由编译器自动分配和释放。
    内存分配：栈的内存分配遵循后进先出（LIFO, Last In First Out）的原则。
    存储内容：通常用于存储函数调用的局部变量、参数和返回地址。
    大小限制：栈的大小在程序启动时就已经确定，且相对较小。
    性能：由于栈是线性的数据结构，内存连续，访问速度快，但是过多的栈空间使用会导致栈溢出。

堆（Heap）

    管理方式：堆的内存分配和释放由程序员手动管理，或通过垃圾收集器进行自动管理（如在Java等语言中）。
    内存分配：堆是一个更为自由的内存区域，程序可以在任何时候请求分配或释放内存。
    存储内容：用于存储生命周期不确定的对象或大量数据，如通过new、malloc等操作动态分配的对象。
    大小限制：堆的大小受到系统可用内存的限制，通常远大于栈。
    性能：堆空间分配的灵活性带来了额外的开销，如寻址、内存碎片等问题，因此访问速度相对较慢。

核心区别

    生命周期和管理：栈由系统自动管理，适用于存储临时变量；而堆的内存分配和释放由程序员控制，适合存储生命周期较长的数据。
    内存分配方式：栈的内存分配是连续的，遵循LIFO原则；堆的内存分配是非连续的，可以随意分配和释放。
    性能和大小：栈因为其连续的内存和自动管理特性，访问速度快但空间有限；堆提供了更大的空间和灵活性，但是管理成本和访问速度是其代价。
```

| \ | 栈stack | 堆heap |
|----------|----------|----------|
| 时效    |  临时    | 持久化     |
| 作用域    | 局部     | 全局     |
| 内存分配    | 自动申请，自动释放（出栈时）     | 手动申请手动释放     |


7. 在下列数据结构中，与所使用的计算机无关的是（）

A.
逻辑结构

B.
存储结构

C.
逻辑结构和存储结构

D.
物理结构

正确答案：
A

`逻辑结构描述了数据元素之间的逻辑关系，比如线性结构、树结构、图结构等。这些逻辑关系是抽象的，与数据在计算机中的实际存储方式无关。因此，逻辑结构是与使用的计算机无关的。 `

`存储结构（也叫物理结构）描述了数据的具体存储形式，比如顺序存储结构（数组）、链式存储结构（链表）、索引存储结构等。存储结构依赖于具体的计算机语言和计算机的存储系统，因此是与计算机相关的。`

8. 对一个算法的评价，不包括()方面的内容。

A.
健壮性和可读性

B.
并行性

C.
正确性

D.
时空复杂度

正确答案：
B

`通常关注其正确性、时空复杂度（也叫高效性，即执行时间和所需内存空间）、健壮性（即对错误输入或意外情况的处理能力）和可读性（即代码的易理解性）、简单性。 并行性：指算法是否能够利用多处理器或多核心的计算资源来同时执行多个操作。`

10. 下列叙述正确的是()。

A.
串是一种特殊的线性表

B.
串的长度必须大于零

C.
串中元素只能是字母

D.
空串就是空白串 `空串（Empty String）: String emptyString = ""; 空白串（Whitespace String）: String whitespaceString = "   ";`

正确答案：
A

11. 在一棵度为3的树中, 度为3的节点个数为2, 度为2的节点个数为1, 度为1的节点个数为0, 则度为0的节点个数为() `度为0意味着没有在向下的子节点了`

A.
4

B.
5

C.
6

D.
7

正确答案：
C

`在树的结构中，"度"指的是节点拥有的子节点的数量。`

```Java
树的边数E（即连接节点的线段数）可以通过所有节点（除了根节点）的总数计算得出，因为树中每一个节点（除了根节点）都正好有一条边与其父节点相连。因此：
E = n0 + n1 + n2 + n3 − 1 

另一个与树的边数相关的公式是考虑度的总和，树中所有节点的度的总和等于树的边数：
n1 + 2*n2 + 3*n3 = E 

将第二个公式中的EE代入得到：
n1 + 2*n2 + 3*n3 = n0 + n1 + n2 + n3−1

0 + 2 + 3*2 = n0 + 0 + 1 + 2 -1
n0 = 6
```

## 三、计算机网络
1. 在当今流行的局域网（local area network，LAN）中, 采用多令牌协议的是()

A.
以太总线网

B.
令牌总线网

C.
令牌环网

D.
光纤分布数据接口

正确答案：
D

`以太总线网不使用多令牌协议，甚至不是令牌传递机制；令牌总线网和令牌环网使用的是单令牌协议传输数据；光纤分布式接口网络使用的是多令牌协议传输数据。`

2. 目前在计算机广域网（Wide Area Network，WAN）中主要采用()技术。

A.
编码解码

B.
电路交换

C.
分组交换

D.
令牌总线

正确答案：
C

3. 下列服务或协议采用53号端口的是()。

A.
域名解析服务 `53`

B.
远程终端协议 `3389`

C.
简单网络管理协议 `161、162`

D.
简单文件传输协议 

正确答案：
A

`SSH 22 | HTTP 80 | HTTPS 443`







