# [单选题]

## 一. 计算机组成原理

1. 机器字长是指()。

A.
存储器单元和寄存器的位数

B.
CPU控制总线根数

C.
CPU地址总线位数

D.
CPU一次能处理的数据位数

正确答案：
D

2. 下列关于中断或异常情况的叙述中，错误的是()。

A.
“访存时缺页”属于中断 `当一个程序尝试访问其虚拟内存空间中的某个部分，而这部分内存当前没有被加载到物理内存（RAM）中时，就会发生缺页异常。`

B.
“整数除以0”属于异常

C.
“DMA传送结束”属于中断 `直接存储访问（Direct Memory Access, DMA）技术，这是一种允许硬件子系统（如磁盘驱动器、声卡等）直接向主内存读写数据而无需CPU介入的技术。当一个DMA传输操作完成时，DMA控制器会向CPU发出一个中断信号，通知CPU数据已成功传输完毕。`

D.
“算术操作数溢出”属于异常

正确答案：
A

`异常也称内中断，是指在处理器和内存内部发生的中断，如缺页中断、算数操作溢出、非法指令、除数为零、地址非法等。中断也称外中断，是指来自处理器和内存以外的部件引起的中断，如I/O中断、外部信号中断等。`



3. 数据的高位保存在存储器的低地址中，而数据的低位保存在存储器的高地址中，这种模式称为()。

A.
小端模式

B.
大端模式

C.
低端模式

D.
高端模式

正确答案：
B

4. 针对8位二进制数，下列说法正确的是()。

A.
-127的补码为10000000 `Two's Complement（补码）1000 0001`

B.
-127的反码等于0的移码 `原码1111 1111，反码1000 0000。移码加上偏移量128，即0+128，也就是1000 0000`

C.
+1的移码等于-127的反码 `One's Complement（反码）` `移码1000 0001`

D.
O的补码等于-1的反码 `原码1000 0001 反码1111 1110`

正确答案：
B

`0和正数反码/补码都是自身，负数补码是反码加1`

5. 若某数x的真值为-0.1010，在计算机中该数表示为1.0110，则该数所用的表示方法是()。

A.
原码 `1.1010`

B.
补码 `1.0110`

C.
反码 `1.0101`

D.
移码

正确答案：
B

6. 已知字符“0”的7位ASCII码是30H，假设在7位ASCII的最高位前面添加一位偶校验位，则字符“1”的偶校验ASCII码是()

A.
B0H `尾数带H，表示是十六进制，Hexadecimal。0011 0001 == 31H，1011 0001 == B1H`

B.
30H

C.
B1H

D.
31H

正确答案：
C

`当我们在这个7位ASCII码的最高位前添加一个偶校验位时，目的是确保整个字节（8位）中“1”的数量是偶数。这样做是为了检测和纠正错误。`

7. 下列说法正确的是()

A.
采用变形补码进行加减运算可以避免溢出 `变形补码可以判断溢出，但是不能避免溢出。浮点数阶码超过上限也会溢出，同号数相加或异号数相减都会产生溢出。`

B.
只有定点数运算才有可能溢出，浮点数运算不会产生溢出

C.
只有带符号数的运算才有可能产生溢出

D.
将两个正数相加有可能产生溢出

正确答案：
D

8. 某DRAM芯片，其存储容量为512Kx8位，该芯片的地址线和数据线数目分别为()。

A.
8，512

B.
512，8

C.
18，8

D.
19，8 `512k == 512 * 1024 == 2^9 + 2^10 == 2^19`

正确答案：
D

`512Kx8表示可以存储512K个8位数据`

```c
存储方式

    SRAM{静态随机存取存储器Static random-access memory}利用双稳态的触发器来存储每一位数据，这意味着它可以在不刷新的情况下保持数据，只要电源保持开启。
    DRAM{动态随机访问存储器Dynamic random-access memory}通过电荷来存储数据，每个数据位被存储在一个微小的电容器中。由于电荷会逐渐泄漏，DRAM需要定期刷新（几毫秒一次）来保持数据。

速度

    SRAM比DRAM快，因为它不需要定期刷新电荷。这使得SRAM更适合作为缓存(Cache, 通常位于CPU内部)使用，在处理器附近提供快速的数据访问。
    DRAM由于其结构原因，访问速度较慢，但是它通常用于作为系统的主内存(内存条)，因为它可以提供更大的存储容量。

成本和容量

    SRAM的成本较高，因为它使用的是比DRAM复杂得多的电路。因此，同等存储容量下，SRAM比DRAM更昂贵，也是为什么SRAM主要用作缓存的原因。
    DRAM成本较低，能够提供更大的存储容量，适合用作系统的主内存。

功耗

    SRAM由于不需要定期刷新，其功耗相对较低（特别是在待机状态下）。
    DRAM需要定期刷新来保持数据，这会导致其在功耗上相对较高。

简而言之，SRAM主要用作高速缓存，因为它速度快、功耗低，但成本高、容量低。DRAM由于其较低的成本和较高的存储密度，通常用作计算机的主内存，尽管它在速度和功耗方面表现不如SRAM。

```

10. 扩展操作码是()。

A.
操作码字段外辅助操作字段的代码

B.
操作码字段中用来进行指令分类的代码

C.
指令格式中的操作码

D.
一种指令优化技术，不同地址数指令可以具有不同的操作码长度

正确答案：
D

`所谓扩展操作码，是指让操作数地址多的指令的操作码字段短一些，操作数地址个数少的指令的操作码字段长一些，这样既能充分地利用指令的各个字段，又能在不增加指令长度的情况下扩展操作码的位数，使它能表示更多的指令。`


11. 对某个寄存器中操作数的寻址方式称为()寻址。

A.
直接

B.
间接

C.
寄存器

D.
寄存器间接 `存的数值的地址`

正确答案：
C


## 二、数据结构与算法

1. 采用顺序查找法查找长度为n的顺序表时，查找成功的平均查找长度为

A.
(n-1)/2

B.
(n+1)/2

C.
n

D.
n/2

正确答案：
B

`    在最好的情况下，查找的长度是1（第一个元素就是要查找的元素）。    在最坏的情况下，查找的长度是n（最后一个元素是要查找的元素）。    因此，查找成功的平均查找长度就是从第一个元素到最后一个元素的平均位置，即(1+n)/2`


2. 在循环队列中用数组A［0, m-1］存放队列元素, 其队头指针和队尾指针分别为front和rear, 则当前队列中的元素个数是()

A.
(front-rear+1)%m

B.
(rear-front+1)%m

C.
(front-rear+m)%m

D.
(rear-front+m)%m

正确答案：
D

```c
    队尾指针在队头指针之后：这是最直接的情况，元素个数直接是rear - front。但是在循环队列中，当队尾绕过数组末尾再从头开始时，这个直接计算就不再适用。

    队尾指针“绕回”到队头指针之前：当队尾指针绕过数组末尾再从头开始，就好像它在队头指针的前面。这时，你需要加上数组的长度m来“补偿”绕回的部分，然后再计算两者的差值，即(rear - front + m)。这样做的目的是确保计算的结果始终为正。{但是此时可能大于m-1个元素了}

    取模运算：使用%m的原因是保证结果落在合理的范围内（0到m-1之间）。这也处理了队列刚好满时（元素个数等于数组长度m）的情况，确保计算结果是正确的。
```

4. 下列关于栈的叙述，正确的是()。

A.
只要确定了入栈序列，就可以确定出栈序列

B.
栈是一种操作受限的线性表，只允许在其两端进行操作 `栈：后进先出。所以为一端`

C.
采用非递归方式重写递归程序时，必须使用栈

D.
函数调用时，可以使用栈来保存必要的信息

正确答案：
D

```java
举个简单的例子，假设有一个入栈序列1, 2, 3。这里有几种不同的出栈情况可能发生：

    如果我们在每个元素入栈后立即出栈，那么出栈序列将是3, 2, 1。
    如果我们让1和2入栈，然后出栈2，入栈3，然后依次出栈3和1，出栈序列将是2, 3, 1。
    如果我们让所有元素入栈，然后依次出栈，出栈序列将是3, 2, 1。

//普通递归版本
public class Factorial {
   public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
    // 定义一个递归方法来计算阶乘
    public static int factorial(int n) {
        // 基本情况
        if (n == 0) {
            return 1;
        }
        // 递归步骤
        else {
            return n * factorial(n - 1);
        }
    }
}

//使用栈stack版本 
import java.util.Stack;
public class FactorialWithStack {    
    public static int factorial(int n) {
        // 创建一个栈来存储中间结果
        Stack<Integer> stack = new Stack<>();        
        // 将n到1的所有数依次入栈
        while (n > 0) {
            stack.push(n);
            n--;
        }        
        // 初始化结果为1
        int result = 1;        
        // 遍历栈，依次弹出所有元素并进行乘法运算
        while (!stack.isEmpty()) {
            result *= stack.pop();
        }        
        return result;
    }
    public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
}

//不使用递归不使用栈版本
public class FactorialNonRecursive {
    // 定义一个非递归方法来计算阶乘
    public static int factorial(int n) {
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
    public static void main(String[] args) {
        // 示例：计算5的阶乘
        int result = factorial(5);
        System.out.println("5! = " + result);
    }
}
```












